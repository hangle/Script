ButtonCardSet (Script)
======================

b Command
-----------
 A ButtonCardSet begins with a command whose tag is 'b'. The  
ButtonCardSet is a CardSet that is invoked by the button labeled   
'+Add'.  The 'b' command allows the presentation of this specialized   
CardSet to be controlled by the user.  
 The 'b' command of the ButtonCardSet has the same functionality  
as  the 'c' command of the CardSet; both clear the screen. Both  
sets have the same commands (display, group, eXecute, assign,  
edit).   The ButtonCardSet is, however, dependent on an  
immediately prior CardSet.  For example:  

		c
		d Capital of Ohio (# $columbus)
		x
		g ($columbus)=(Columbus)
		d Correct
		ge 
		d Sorry, Columbus is correct
						.
		b
		d The capital is named after the
		d person who discovered the New
		d World

		* end

A CardSet with a following ButtonCardSet has its '+Add' button   
enabled; its color changes from grey to yellow.  Failure to  
activate the '+Add' button causes the ButtonCardSet to be skipped.  
Activation of this button causes the execution of the ButtonCardSet.  

When the ButtonCardSet terminates, the user is returned to the    
associated CardSet.  It is hoped that the supplemental probe of the  
New World is sufficient to achieve the correct response-- 'Columbus'.  


Approach
--------
The script program (script.scala) validates the '*.nc' file commands   
(ParseValidator class.).  The 'CommandMaker.distributeScriptToMaker'  
invokes functions to handle a specified tag (like 'c' or 'b').  The 'c'   
and 'b' commands both clear the Notecard panel.  Both comands are  
leading tags of the CardSet command group.  The CommandMaker class   
matches  the 'c' and 'b' tags.  Since both commands have the same   
functionality,   CommandMaker invokes the 'CardCommand.cardCommand' for    
both; however, this    function is passed "CardSet" or "ButtonCardSet"    
to establish later distinction  when 'CardScript.cardScript' is invoked.  

<pre>
			case 'c' =>
				CardCommand.cardCommand(..., "CardSet")
			case 'b' =>
				CardCommand.cardCommand(..., "ButtonCardSet")
</pre>

CardScript.cardScript write commands to 'script:ArrayBuffer[String]'.    

<pre>
			%CardSet		<  >		%ButtonCardSet
			name    ...`                name   ...
			condition ...               condition
			%%                          %%
</pre>

The script program next builds the linked list structure with the    
'BuildStructure' class, passing 'script:ArrayBuffer[String]' to   
'buildStructure'. The output of  'buildStructure' is   
'struct:ArrayBuffer[String]'. 'struct' has the same information    
as that of 'script', that is:  

			<%classname> 
			parameters 
			<%%>

Missing from the original 'struct' ArrayBuffer are symbolic   
addresses:   

			<%classname>
			<address>
			<child address>
			<sibling address>
			parameters
			<%%>

Also missing from the '%CardSet' of our Ohio Capital script example is a new   
symbolic  address labeled Button (i.e., 2013):  

			%CardSet
			2002			 <Address of CardSet>
			2003			 <Address of child (%RowerNode) >
			2020			 <Address of Next sibling (%NotecardTask [end]) >
			2013			 <Address of '%ButtonCardSet'>
			name	0
			condition	0
			<%%>

In 'BuildStructure', the symbolic address of Button prior to the invocation   
of  

			ButtonCardSetRemap.buttonCardSetRemap(struct)

was  zero, for example:

			%CardSet
			2002			 <Address of CardSet>
			2003			 <Address of child (%RowerNode) >
			2013			 <Address of Next sibling (%ButtonCardSet) >
			0			 	 <Address effectively null >
			name	0
			condition	0
			<%%>

'buttonCardSetRemap(struct)' moved the symbolic address from Next sibling to   
Button.  In turn,  its finds the symbolic address of the next sibling; in this   
case the address is  '%NotecardTask'.


